import sys

sys.path.append('../')
import os.path
from PIL import Image
import random
from io import BytesIO
import cv2
import numpy as np
import os
from skimage import color, data, restoration, io
import shutil
from scipy import special
from scipy.stats import multivariate_normal
from basicsr.utils import img2tensor, tensor2img, DiffJPEG
from basicsr.utils.img_process_util import filter2D
from torch.nn import functional as F
from basicsr.data.degradations import circular_lowpass_kernel, random_mixed_kernels,random_add_gaussian_noise_pt
import torch
import scipy.io as scio



# 每个函数的输入输出都是cv2形式

def down_tensor(img):
    ori_h, ori_w = img.size()[2:4]

    scale = 0.5
    mode = 'bicubic'
    img = F.interpolate(img, scale_factor=scale, mode=mode)


    return img

def resize_tensor(img):

    ori_h, ori_w = img.size()[2:4]

    scale = 0.25
    mode = 'bicubic'
    img = F.interpolate(img, scale_factor=scale, mode=mode)

    mode = 'bicubic'
    img = F.interpolate(img, size=(ori_h // 1, ori_w // 1),
                        mode=mode)

    return img


def zero_mask(size):
    x = np.zeros((size, size, 3)).astype('uint8')
    mask = Image.fromarray(x).convert("RGB")
    return mask

def pdf2(sigma_matrix, grid):
    """Calculate PDF of the bivariate Gaussian distribution.

    Args:
        sigma_matrix (ndarray): with the shape (2, 2)
        grid (ndarray): generated by :func:`mesh_grid`,
            with the shape (K, K, 2), K is the kernel size.

    Returns:
        kernel (ndarrray): un-normalized kernel.
    """
    inverse_sigma = np.linalg.inv(sigma_matrix)
    kernel = np.exp(-0.5 * np.sum(np.dot(grid, inverse_sigma) * grid, 2))
    return kernel

def mesh_grid(kernel_size):
    """Generate the mesh grid, centering at zero.

    Args:
        kernel_size (int):

    Returns:
        xy (ndarray): with the shape (kernel_size, kernel_size, 2)
        xx (ndarray): with the shape (kernel_size, kernel_size)
        yy (ndarray): with the shape (kernel_size, kernel_size)
    """
    ax = np.arange(-kernel_size // 2 + 1., kernel_size // 2 + 1.)
    xx, yy = np.meshgrid(ax, ax)
    xy = np.hstack((xx.reshape((kernel_size * kernel_size, 1)), yy.reshape(kernel_size * kernel_size,
                                                                           1))).reshape(kernel_size, kernel_size, 2)
    return xy, xx, yy

def bivariate_Gaussian(kernel_size, sig_x, grid=None, isotropic=True):
    """Generate a bivariate isotropic or anisotropic Gaussian kernel.

    In the isotropic mode, only `sig_x` is used. `sig_y` and `theta` is ignored.

    Args:
        kernel_size (int):
        sig_x (float):
        sig_y (float):
        theta (float): Radian measurement.
        grid (ndarray, optional): generated by :func:`mesh_grid`,
            with the shape (K, K, 2), K is the kernel size. Default: None
        isotropic (bool):

    Returns:
        kernel (ndarray): normalized kernel.
    """
    if grid is None:
        grid, _, _ = mesh_grid(kernel_size)
    if isotropic:
        sigma_matrix = np.array([[sig_x ** 2, 0], [0, sig_x ** 2]])
    else:
        sigma_matrix = sigma_matrix2(sig_x, sig_y, theta)
    kernel = pdf2(sigma_matrix, grid)
    kernel = kernel / np.sum(kernel)
    return kernel

def pil_to_np(img_PIL):
    '''Converts image in PIL format to np.array.
    From W x H x C [0...255] to C x W x H [0..1]
    '''
    ar = np.array(img_PIL)

    if len(ar.shape) == 3:
        ar = ar.transpose(2, 0, 1)
    else:
        ar = ar[None, ...]

    return ar.astype(np.float32) / 255.

def np_to_pil(img_np):
    '''Converts image in np.array format to PIL image.
    From C x W x H [0..1] to  W x H x C [0...255]
    '''
    ar = np.clip(img_np * 255, 0, 255).astype(np.uint8)

    if img_np.shape[0] == 1:
        ar = ar[0]
    else:
        ar = ar.transpose(1, 2, 0)

    return Image.fromarray(ar)

def blur_tensor(img,ks,num):
    kernel1= bivariate_Gaussian(ks, num, grid=None, isotropic=True)
    kernel1 = torch.FloatTensor(kernel1)
    img = filter2D(img, kernel1)
    return img


def check_dir(dir):
    if os.path.exists(dir):
        pass
    else:
        os.makedirs(dir)

def r_l(img):

    psf = np.ones((1, 1, 5, 5))
    psf = psf / psf.sum()
    img = img.numpy()
    img = np.pad(img, ((0, 0), (0, 0), (7, 7), (7, 7)), 'linear_ramp')
    img = restoration.richardson_lucy(img, psf, 1)
    img = img[:, :, 7:-7, 7:-7]
    img = torch.from_numpy(img)

    return img


def sinc(img, kernel_size,omega_c):

    sinc_kernel = circular_lowpass_kernel(omega_c, kernel_size, pad_to=21)
    sinc_kernel = torch.FloatTensor(sinc_kernel)

    img = filter2D(img,sinc_kernel)

    return img


def circular_lowpass_kernel(cutoff, kernel_size, pad_to=0):
    """2D sinc filter, ref: https://dsp.stackexchange.com/questions/58301/2-d-circularly-symmetric-low-pass-filter

    Args:
        cutoff (float): cutoff frequency in radians (pi is max)
        kernel_size (int): horizontal and vertical size, must be odd.
        pad_to (int): pad kernel size to desired size, must be odd or zero.
    """
    assert kernel_size % 2 == 1, 'Kernel size must be an odd number.'
    kernel = np.fromfunction(
        lambda x, y: cutoff * special.j1(cutoff * np.sqrt(
            (x - (kernel_size - 1) / 2) ** 2 + (y - (kernel_size - 1) / 2) ** 2)) / (2 * np.pi * np.sqrt(
            (x - (kernel_size - 1) / 2) ** 2 + (y - (kernel_size - 1) / 2) ** 2)), [kernel_size, kernel_size])
    kernel[(kernel_size - 1) // 2, (kernel_size - 1) // 2] = cutoff ** 2 / (4 * np.pi)
    kernel = kernel / np.sum(kernel)
    if pad_to > kernel_size:
        pad_size = (pad_to - kernel_size) // 2
        kernel = np.pad(kernel, ((pad_size, pad_size), (pad_size, pad_size)))
    return kernel

def convertToJpeg(img, q):
    jpeger = DiffJPEG(differentiable=False)

    img = torch.clamp(img, 0, 1)
    img = jpeger(img, quality=q)
    return img



def inpainting(img,l_num,l_thick):
    # inpainting
    ori_h, ori_w = img.size()[2:4]
    mask = np.zeros((ori_h, ori_w, 3), np.uint8)
    # l_num = random.randint(5, 10)
    # l_thick = random.randint(5, 10)
    col = random.choice(['white', 'black'])
    while (l_num):
        x1, y1 = random.randint(0, ori_w), random.randint(0, ori_h)
        x2, y2 = random.randint(0, ori_w), random.randint(0, ori_h)
        pts = np.array([[x1, y1], [x2, y2]], np.int32)
        pts = pts.reshape((-1, 1, 2))
        mask = cv2.polylines(mask, [pts], 0, (1, 1, 1), l_thick)
        l_num -= 1
    mask = img2tensor([mask], bgr2rgb=True, float32=True)[0]

    if col == 'white':
        img = torch.clamp(img + mask, 0, 1)  # 白线，加上
    else:
        img = torch.clamp(img - mask, 0, 1)  # 黑线，减去

    return img

def add_rain(img,value):
    w, h, c = img.shape
    h = h - (h % 4)
    w = w - (w % 4)
    img = img[0:w, 0:h, :]


    w = np.random.choice([3, 5, 7, 9, 11], p=[0.2, 0.2, 0.2, 0.2, 0.2])  # 粗细
    length = np.random.randint(20, 41)  # 长度
    angle = np.random.randint(-45, 45)  # 角度

    noise = get_noise(img, value=value)
    rain = rain_blur(noise, length=length, angle=angle, w=w)

    img = img.astype('float32') + rain
    np.clip(img, 0, 255, out=img)
    return img

def get_noise(img, value=10):
    '''
    #生成噪声图像
    >>> 输入： img图像
        value= 大小控制雨滴的多少
    >>> 返回图像大小的模糊噪声图像
    '''

    noise = np.random.uniform(0, 256, img.shape[0:2])
    # 控制噪声水平，取浮点数，只保留最大的一部分作为噪声
    v = value * 0.01
    noise[np.where(noise < (256 - v))] = 0

    # 噪声做初次模糊
    k = np.array([[0, 0.1, 0],
                  [0.1, 8, 0.1],
                  [0, 0.1, 0]])

    noise = cv2.filter2D(noise, -1, k)

    # 可以输出噪声看看
    '''cv2.imshow('img',noise)
    cv2.waitKey()
    cv2.destroyWindow('img')'''
    return noise

def rain_blur(noise, length=10, angle=0, w=1):
    '''
    将噪声加上运动模糊,模仿雨滴

    >>>输入
    noise：输入噪声图，shape = img.shape[0:2]
    length: 对角矩阵大小，表示雨滴的长度
    angle： 倾斜的角度，逆时针为正
    w:      雨滴大小

    >>>输出带模糊的噪声

    '''

    # 这里由于对角阵自带45度的倾斜，逆时针为正，所以加了-45度的误差，保证开始为正
    trans = cv2.getRotationMatrix2D((length / 2, length / 2), angle - 45, 1 - length / 100.0)
    dig = np.diag(np.ones(length))  # 生成对焦矩阵
    k = cv2.warpAffine(dig, trans, (length, length))  # 生成模糊核
    k = cv2.GaussianBlur(k, (w, w), 0)  # 高斯模糊这个旋转后的对角核，使得雨有宽度

    # k = k / length                         #是否归一化

    blurred = cv2.filter2D(noise, -1, k)  # 用刚刚得到的旋转后的核，进行滤波

    # 转换到0-255区间
    cv2.normalize(blurred, blurred, 0, 255, cv2.NORM_MINMAX)
    blurred = np.array(blurred, dtype=np.uint8)

    rain = np.expand_dims(blurred, 2)
    blurred = np.repeat(rain, 3, 2)
    # cv2.imwrite('./rain_mask.png',blurred)
    '''
    cv2.imshow('img',blurred)
    cv2.waitKey()
    cv2.destroyWindow('img')'''

    return blurred

def add_haze(img,depth_path,A,B):

    depth_data = scio.loadmat(depth_path)
    depth_arr = depth_data['data_obj']

    w, h = depth_arr.shape

    depth_arr = cv2.resize(depth_arr, (h * 4, w * 4))

    depth_arr = depth_arr / depth_arr.max()

    w, h, c = img.shape
    h = h - (h % 4)
    w = w - (w % 4)
    img = img[0:w, 0:h, :]

    T = np.exp(-B * depth_arr)
    T = np.expand_dims(T, axis=2)

    img = img * T + A * 255 * (1 - T)

    return img

def add_dark(img,gamma):

    gamma_img = np.power(img, gamma)

    return gamma_img


def add_snow(img,depth_path,mask_path,A,B):

    mask = cv2.imread(mask_path)

    w, h, c = img.shape
    h = h - (h % 4)
    w = w - (w % 4)
    img = img[0:w, 0:h, :]

    w_m, h_m, _ = mask.shape

    # mask = mask[:int(w_m / 2), :int(h_m / 2), :]

    mask = cv2.resize(mask, (h, w))

    img = img.astype('float32') * (1 - mask / 255.) + 1 * mask

    np.clip(img, 0, 255, out=img)

    depth_data = scio.loadmat(depth_path)
    depth_arr = depth_data['data_obj']

    w, h = depth_arr.shape

    depth_arr = cv2.resize(depth_arr, (h * 4, w * 4))

    depth_arr = depth_arr / depth_arr.max()


    T = np.exp(-B * depth_arr)
    T = np.expand_dims(T, axis=2)

    img = img * T + A * 255 * (1 - T)

    return img

if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument('--start', type=int, default='0',
                        help='Input image or folder')
    parser.add_argument('--end', type=int, default='0',
                        help='Input image or folder')
    args = parser.parse_args()

    # dir='/opt/data/private/GLV/GLV_data/GT/GT_GT'
    # save_dir='/opt/data/private/GLV/GLV_data/dark/dark'

    dir='your path/MiO/data/DF2K/GT'
    save_dir='your path/MiO/data/DF2K/haze'


    degradation = 'haze' #'blur', 'noise', 'jpeg','dark'
    check_dir(save_dir)


    for img_p in sorted(os.listdir(dir)):
        print(img_p)

        depth_path = 'your path/MiO/data/DF2K/depth/{}.mat'.format(
            img_p[:-4])


        kernel_range = [2 * v + 1 for v in range(3, 11)]
        ks = random.choice(kernel_range)
        sthd = round(random.uniform(1, 3), 2)

        sthb = round(random.uniform(1, 3), 2)

        sthn = round(random.uniform(15, 50))

        sthj = round(random.uniform(30, 70))

        save_LR_path=os.path.join(save_dir,img_p)
        img_path=os.path.join(dir,img_p)
        img = cv2.imread(img_path)

        if degradation == 'rain':
            # rain
            value = np.random.randint(50, 100)  # 雨线数目
            # value = 75  # 雨线数目
            img = add_rain(img, value)


        if degradation == 'haze':
            # haze
            A = round(random.uniform(0.8, 1), 2)
            B = round(random.uniform(0.5, 2.5), 2)
            # A = 0.9
            # B = 1.8
            img = add_haze(img, depth_path, A, B)

        img = img2tensor([img])[0].unsqueeze(0) / 255.

        img = torch.clamp((img * 255.0).round(), 0, 255) / 255.

        if degradation == 'dark':

            img = add_dark(img,sthd)
            img = torch.clamp((img * 255.0).round(), 0, 255) / 255.

        if degradation == 'blur':
            # blur

            img = blur_tensor(img, ks, sthb)
            img = torch.clamp((img * 255.0).round(), 0, 255) / 255.

        if degradation == 'noise':
            # noise

            img = random_add_gaussian_noise_pt(
                img, sigma_range=[sthn, sthn], clip=True, rounds=False,
                gray_prob=0)
            img = torch.clamp((img * 255.0).round(), 0, 255) / 255.

        if degradation == 'jpeg':
            # jpeg

            img = convertToJpeg(img, sthj)
            img = torch.clamp((img * 255.0).round(), 0, 255) / 255.
        
        if degradation == 'sr':
            img=resize_tensor(img)
            img = torch.clamp((img * 255.0).round(), 0, 255) / 255.




        img = tensor2img(img, min_max=(0, 1))
        cv2.imwrite(os.path.join(save_LR_path), img)







